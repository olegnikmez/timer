<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ChronoFlex Pro</title>
    
    <!-- Подключаем стили Tailwind (Дизайн) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Подключаем React и ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (чтобы браузер понял современный код) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Отключаем выделение текста на мобильных для ощущения приложения */
        body {
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            background-color: #111827; /* bg-gray-900 */
            /* CRITICAL FIX: Используем dynamic viewport height для мобильных браузеров */
            height: 100vh;
            height: 100dvh; 
            width: 100vw;
            overflow: hidden;
        }
        /* Анимации */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.5s ease-out forwards;
        }
        /* Безопасные зоны для телефонов с "челками" */
        .safe-top { padding-top: env(safe-area-inset-top); }
        .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
        
        /* Скрываем скроллбар для красоты, но оставляем возможность скролла */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ВСТРОЕННЫЕ ИКОНКИ ---
        const Icons = {
            Play: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
            Pause: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
            RotateCcw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>,
            Plus: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>,
            Trash2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>,
            Settings: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>,
            Volume2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>,
            VolumeX: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>,
            Music: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>,
            Check: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>,
            X: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Upload: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>,
            ArrowUp: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>,
            ArrowDown: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>,
            Copy: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>,
            SkipForward: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>,
            SkipBack: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line></svg>,
            List: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>,
            Edit: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
        };

        const { Play, Pause, RotateCcw, Plus, Trash2, Settings, Volume2, VolumeX, Music, Check, X, Upload, ArrowUp, ArrowDown, Copy, SkipForward, SkipBack, List, Edit } = Icons;

        // --- DATABASE UTILS (IndexedDB) ---
        const DB_NAME = 'ChronoFlexAudioDB';
        const STORE_NAME = 'audio_files';

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        };

        const saveAudioToDB = async (id, file) => {
            try {
                const db = await initDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).put(file, id);
                return new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (err) { console.error("DB Error", err); }
        };

        const getAudioFromDB = async (id) => {
            try {
                const db = await initDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });
            } catch (err) { return null; }
        };

        const deleteAudioFromDB = async (id) => {
            try {
                const db = await initDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).delete(id);
            } catch (err) {}
        };

        // --- SOUND ENGINE ---
        const playSound = (type, customBlobUrl = null) => {
            if (type === 'custom' && customBlobUrl) {
                const audio = new Audio(customBlobUrl);
                audio.play().catch(e => console.log(e));
                return;
            }

            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            const now = ctx.currentTime;

            switch (type) {
                case 'bell':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(330, now);
                    const osc2 = ctx.createOscillator();
                    const gain2 = ctx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(ctx.destination);
                    osc2.frequency.setValueAtTime(587, now);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 2.5);
                    gain2.gain.setValueAtTime(0.3, now);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    osc.start(now); osc.stop(now + 2.5);
                    osc2.start(now); osc2.stop(now + 2.5);
                    break;
                case 'whistle':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(1500, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'game':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.setValueAtTime(880, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.21);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'high':
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'finish':
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                        const o = ctx.createOscillator();
                        const g = ctx.createGain();
                        o.connect(g);
                        g.connect(ctx.destination);
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.2, now + i * 0.15);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 1);
                        o.start(now + i * 0.15);
                        o.stop(now + i * 0.15 + 1);
                    });
                    break;
                default:
                    osc.frequency.setValueAtTime(440, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
            }
        };

        const formatTime = (seconds) => {
            const safeSeconds = Number(seconds) || 0;
            const m = Math.floor(safeSeconds / 60).toString().padStart(2, '0');
            const s = (safeSeconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        };

        // --- MAIN APP COMPONENT ---
        function ChronoFlexTimer() {
            // --- STATE MANAGEMENT WITH SCHEMES ---
            
            // 1. Инициализация Схем
            const [schemes, setSchemes] = useState(() => {
                const savedSchemes = localStorage.getItem('chrono_schemes');
                if (savedSchemes) {
                    try { return JSON.parse(savedSchemes); } catch (e) {}
                }
                
                // Миграция данных старых пользователей
                const oldIntervals = localStorage.getItem('chrono_intervals');
                const oldCycles = localStorage.getItem('chrono_cycles');
                
                const defaultIntervals = [
                    { id: 1, name: 'Разминка', duration: 10, color: '#10b981', soundType: 'low', customUrl: null },
                    { id: 2, name: 'Работа', duration: 30, color: '#ef4444', soundType: 'bell', customUrl: null },
                    { id: 3, name: 'Отдых', duration: 15, color: '#3b82f6', soundType: 'low', customUrl: null }
                ];

                const initialScheme = {
                    id: Date.now(),
                    name: 'Моя тренировка',
                    cycles: oldCycles ? parseInt(oldCycles) : 1,
                    intervals: oldIntervals ? JSON.parse(oldIntervals) : defaultIntervals
                };

                return [initialScheme];
            });

            // 2. Инициализация активной схемы
            const [activeSchemeId, setActiveSchemeId] = useState(() => {
                const lastId = localStorage.getItem('chrono_active_scheme_id');
                // Проверяем, существует ли схема с таким ID
                if (lastId) {
                    // Так как мы пока не можем обратиться к state `schemes` внутри инициализатора,
                    // мы доверяем ID, но сделаем проверку в рендере или useEffect
                    return parseInt(lastId);
                }
                return null; // Будет установлено в useEffect
            });

            // 3. Состояние Mute (Глобальный звук)
            const [isMuted, setIsMuted] = useState(() => {
                return localStorage.getItem('chrono_is_muted') === 'true';
            });

            useEffect(() => {
                localStorage.setItem('chrono_is_muted', isMuted);
            }, [isMuted]);

            // Вычисляемая активная схема. Если ID некорректен, берем первую.
            const activeScheme = schemes.find(s => s.id === activeSchemeId) || schemes[0];
            
            // Синхронизация: если activeSchemeId был null или неверный, обновляем его
            useEffect(() => {
                if (!activeSchemeId || !schemes.find(s => s.id === activeSchemeId)) {
                    setActiveSchemeId(schemes[0].id);
                }
            }, [schemes, activeSchemeId]);

            // Сохранение в LocalStorage
            useEffect(() => {
                // Сохраняем схемы без blob url
                const schemesToSave = schemes.map(scheme => ({
                    ...scheme,
                    intervals: scheme.intervals.map(i => ({ ...i, customUrl: null }))
                }));
                localStorage.setItem('chrono_schemes', JSON.stringify(schemesToSave));
                localStorage.setItem('chrono_active_scheme_id', activeScheme.id.toString());
            }, [schemes, activeScheme]);


            // --- Helper Functions для управления схемами ---

            const updateActiveScheme = (updates) => {
                setSchemes(prevSchemes => 
                    prevSchemes.map(s => s.id === activeScheme.id ? { ...s, ...updates } : s)
                );
            };

            const addNewScheme = () => {
                const newId = Date.now();
                const newScheme = {
                    id: newId,
                    name: `Тренировка ${schemes.length + 1}`,
                    cycles: 1,
                    intervals: [
                        { id: Date.now() + 1, name: 'Работа', duration: 30, color: '#ef4444', soundType: 'bell', customUrl: null },
                        { id: Date.now() + 2, name: 'Отдых', duration: 15, color: '#3b82f6', soundType: 'low', customUrl: null }
                    ]
                };
                setSchemes([...schemes, newScheme]);
                setActiveSchemeId(newId);
                resetTimer(); // Сбрасываем таймер при смене схемы
            };

            const deleteActiveScheme = () => {
                if (schemes.length <= 1) return; // Нельзя удалить последнюю
                const newSchemes = schemes.filter(s => s.id !== activeScheme.id);
                setSchemes(newSchemes);
                setActiveSchemeId(newSchemes[0].id);
                resetTimer();
            };

            const switchScheme = (id) => {
                setActiveSchemeId(id);
                resetTimer();
            };

            // --- ОБЫЧНЫЙ STATE ТАЙМЕРА (Сбрасывается при смене схемы) ---
            const [currentCycle, setCurrentCycle] = useState(1);
            const [currentIntervalIndex, setCurrentIntervalIndex] = useState(0);
            const [timeLeft, setTimeLeft] = useState(0);
            const [status, setStatus] = useState('idle');
            const [mode, setMode] = useState('timer');
            const [isSchemeListOpen, setIsSchemeListOpen] = useState(false); // Для выпадающего списка схем

            const endTimeRef = useRef(null);
            const rafRef = useRef(null);
            const wakeLockRef = useRef(null);

            // Эффект обновления времени при смене активной схемы/интервалов
            useEffect(() => {
                if (status === 'idle') {
                    const firstInterval = activeScheme.intervals[0];
                    setTimeLeft(firstInterval ? (Number(firstInterval.duration) || 0) : 0);
                }
            }, [activeScheme, status]);


            // Восстановление аудио для ВСЕХ интервалов текущей схемы
            useEffect(() => {
                const restoreAudio = async () => {
                    let hasChanges = false;
                    const updatedSchemes = [...schemes];
                    const schemeIndex = updatedSchemes.findIndex(s => s.id === activeScheme.id);
                    if (schemeIndex === -1) return;

                    const currentIntervals = [...updatedSchemes[schemeIndex].intervals];

                    for (let i = 0; i < currentIntervals.length; i++) {
                        if (currentIntervals[i].soundType === 'custom' && !currentIntervals[i].customUrl) {
                            const fileBlob = await getAudioFromDB(currentIntervals[i].id);
                            if (fileBlob) {
                                currentIntervals[i].customUrl = URL.createObjectURL(fileBlob);
                                hasChanges = true;
                            }
                        }
                    }
                    
                    if (hasChanges) {
                        updatedSchemes[schemeIndex].intervals = currentIntervals;
                        setSchemes(updatedSchemes);
                    }
                };
                restoreAudio();
            }, [activeSchemeId]); // Запускаем при смене схемы


            const requestWakeLock = async () => {
                try { if ('wakeLock' in navigator) wakeLockRef.current = await navigator.wakeLock.request('screen'); } catch (err) {}
            };

            const startTimer = () => {
                if (status === 'finished') { resetTimer(); return; }
                setStatus('running');
                requestWakeLock();
                endTimeRef.current = Date.now() + (Number(timeLeft) || 0) * 1000;
                
                // Проигрываем звук если это начало
                const originalDuration = Number(activeScheme.intervals[currentIntervalIndex].duration) || 0;
                if (timeLeft === originalDuration && !isMuted) {
                    const current = activeScheme.intervals[currentIntervalIndex];
                    playSound(current.soundType, current.customUrl);
                }
            };

            const pauseTimer = () => {
                setStatus('paused');
                if (wakeLockRef.current) wakeLockRef.current.release();
                if (rafRef.current) cancelAnimationFrame(rafRef.current);
            };

            const resetTimer = () => {
                pauseTimer(); // Cleans up wakeLock and raf, sets 'paused'
                setStatus('idle'); // Overrides to 'idle'
                setCurrentCycle(1);
                setCurrentIntervalIndex(0);
                
                // Исправление: принудительно сбрасываем время, чтобы убрать добавленные секунды
                const firstInterval = activeScheme.intervals[0];
                setTimeLeft(firstInterval ? (Number(firstInterval.duration) || 0) : 0);
            };

            const addSeconds = (amount) => {
                setTimeLeft(prev => {
                    const newVal = prev + amount;
                    if (status === 'running') {
                        endTimeRef.current += amount * 1000;
                    }
                    return newVal;
                });
            };

            const tick = useCallback(() => {
                if (status !== 'running') return;
                const now = Date.now();
                const remainingMs = endTimeRef.current - now;
                const remainingSec = Math.ceil(remainingMs / 1000);

                if (remainingSec !== timeLeft) setTimeLeft(remainingSec >= 0 ? remainingSec : 0);

                if (remainingMs <= 0) handleIntervalComplete();
                else rafRef.current = requestAnimationFrame(tick);
            }, [status, timeLeft, activeScheme, isMuted]); 

            useEffect(() => {
                if (status === 'running') rafRef.current = requestAnimationFrame(tick);
                return () => cancelAnimationFrame(rafRef.current);
            }, [status, tick]);

            const handleIntervalComplete = () => {
                const nextIndex = currentIntervalIndex + 1;
                const intervals = activeScheme.intervals;
                
                if (nextIndex < intervals.length) {
                    setCurrentIntervalIndex(nextIndex);
                    const nextInterval = intervals[nextIndex];
                    setTimeLeft(Number(nextInterval.duration) || 0);
                    endTimeRef.current = Date.now() + (Number(nextInterval.duration) || 0) * 1000;
                    if (!isMuted) playSound(nextInterval.soundType, nextInterval.customUrl);
                } else {
                    if (currentCycle < activeScheme.cycles) {
                        setCurrentCycle(c => c + 1);
                        setCurrentIntervalIndex(0);
                        const first = intervals[0];
                        setTimeLeft(Number(first.duration) || 0);
                        endTimeRef.current = Date.now() + (Number(first.duration) || 0) * 1000;
                        if (!isMuted) playSound(first.soundType, first.customUrl);
                    } else {
                        setStatus('finished');
                        setTimeLeft(0);
                        if (!isMuted) playSound('finish');
                    }
                }
            };

            // --- NAVIGATION (Skip Backward/Forward) ---
            const handleSkipBackward = () => {
                // Логика: если есть предыдущий интервал, идем к нему.
                // Если это первый интервал цикла, но цикл > 1, идем к последнему интервалу предыдущего цикла.
                // Иначе просто сбрасываем время в начало.
                
                let newIndex = currentIntervalIndex - 1;
                let newCycle = currentCycle;

                if (newIndex < 0) {
                    if (currentCycle > 1) {
                        newCycle = currentCycle - 1;
                        newIndex = activeScheme.intervals.length - 1;
                    } else {
                        // Самое начало тренировки - просто сброс
                        resetTimer();
                        return;
                    }
                }

                setCurrentCycle(newCycle);
                setCurrentIntervalIndex(newIndex);
                
                const prevInterval = activeScheme.intervals[newIndex];
                const newDuration = Number(prevInterval.duration) || 0;
                setTimeLeft(newDuration);
                
                // Звук теперь воспроизводится всегда при переходе (если не выключен звук)
                if (!isMuted) playSound(prevInterval.soundType, prevInterval.customUrl);

                // Если таймер запущен, продолжаем отсчет с нового места
                if (status === 'running') {
                    endTimeRef.current = Date.now() + newDuration * 1000;
                }
            };

            // --- Scheme Data Modifiers (Wrapped activeScheme updaters) ---

            const addInterval = () => {
                const newId = Date.now();
                const newIntervals = [...activeScheme.intervals, { 
                    id: newId, 
                    name: 'Новый этап', 
                    duration: 30, 
                    color: '#6366f1', 
                    soundType: 'low', 
                    customUrl: null 
                }];
                updateActiveScheme({ intervals: newIntervals });
            };

            const removeInterval = (id) => {
                if (activeScheme.intervals.length > 1) {
                    const newIntervals = activeScheme.intervals.filter(i => i.id !== id);
                    updateActiveScheme({ intervals: newIntervals });
                    deleteAudioFromDB(id);
                }
            };

            const duplicateInterval = (id) => {
                const index = activeScheme.intervals.findIndex(i => i.id === id);
                if (index === -1) return;
                const source = activeScheme.intervals[index];
                const newInterval = { ...source, id: Date.now(), name: source.name + ' (Копия)' };
                const newIntervals = [...activeScheme.intervals];
                newIntervals.splice(index + 1, 0, newInterval);
                updateActiveScheme({ intervals: newIntervals });
            };

            const moveInterval = (index, direction) => {
                if (direction === -1 && index === 0) return;
                if (direction === 1 && index === activeScheme.intervals.length - 1) return;
                const newIntervals = [...activeScheme.intervals];
                const temp = newIntervals[index];
                newIntervals[index] = newIntervals[index + direction];
                newIntervals[index + direction] = temp;
                updateActiveScheme({ intervals: newIntervals });
            };

            const updateIntervalData = (id, field, value) => {
                const newIntervals = activeScheme.intervals.map(i => i.id === id ? { ...i, [field]: value } : i);
                updateActiveScheme({ intervals: newIntervals });
            };

            const handleFileUpload = async (id, file) => {
                if (file) {
                    await saveAudioToDB(id, file);
                    const url = URL.createObjectURL(file);
                    const newIntervals = activeScheme.intervals.map(i => i.id === id ? { ...i, soundType: 'custom', customUrl: url } : i);
                    updateActiveScheme({ intervals: newIntervals });
                }
            };


            const currentInterval = activeScheme.intervals[currentIntervalIndex] || {};
            const safeDuration = Number(currentInterval.duration) || 1; 
            const progressPercent = status === 'idle' ? 100 : (timeLeft / safeDuration) * 100;

            // --- RENDER ---

            if (mode === 'timer') {
                return (
                    <div className="flex flex-col h-full w-full overflow-hidden transition-colors duration-700 relative"
                        style={{ backgroundColor: status !== 'idle' && status !== 'finished' ? `${currentInterval.color}20` : '#111827' }}>
                        
                        <div className="flex justify-between items-center p-6 safe-top z-10 flex-shrink-0">
                            <div className="flex flex-col">
                                <span className="text-xs font-bold uppercase tracking-widest text-gray-400">{activeScheme.name}</span>
                                <div className="text-sm font-medium opacity-70 tracking-widest uppercase">Цикл {currentCycle} / {activeScheme.cycles}</div>
                            </div>
                            <div className="flex gap-2">
                                <button 
                                    onClick={() => setIsMuted(!isMuted)} 
                                    className={`p-2 rounded-full transition ${isMuted ? 'bg-red-500/20 text-red-400' : 'bg-gray-800 text-gray-300'}`}
                                >
                                    {isMuted ? <VolumeX size={20} /> : <Volume2 size={20} />}
                                </button>
                                <button onClick={() => { resetTimer(); setMode('edit'); }} className="p-2 bg-gray-800 rounded-full hover:bg-gray-700 transition"><Settings size={20} /></button>
                            </div>
                        </div>

                        {/* --- MAIN DISPLAY LAYOUT (Scrollable if too small) --- */}
                        <div className="flex-1 flex flex-col items-center justify-evenly w-full max-w-md mx-auto px-6 relative z-0 overflow-y-auto no-scrollbar min-h-0">
                            
                            {/* Interval Name */}
                            <h2 className="text-3xl sm:text-4xl font-light text-center px-4 animate-fade-in z-10 relative mt-4">
                                {status === 'finished' ? 'Тренировка завершена!' : currentInterval.name}
                            </h2>

                            {/* Circle Container - Responsive height */}
                            <div className="relative w-64 h-64 sm:w-80 sm:h-80 max-h-[50vh] aspect-square flex items-center justify-center my-4 shrink-0">
                                {/* SVG/Border Circle */}
                                <div className="absolute inset-0 rounded-full border-8 transition-colors duration-500" 
                                     style={{ borderColor: currentInterval.color || '#333' }}>
                                </div>
                                
                                {/* Time Text */}
                                <div className="text-7xl sm:text-8xl font-bold tracking-tighter tabular-nums drop-shadow-2xl z-10 select-none" 
                                     style={{ color: status === 'finished' ? '#10b981' : currentInterval.color }}>
                                    {formatTime(timeLeft)}
                                </div>
                            </div>

                            {/* Add Time Buttons */}
                            <div className="flex gap-3 z-10 shrink-0 mb-4">
                                {[1, 2, 3, 5].map(sec => (
                                    <button 
                                        key={sec}
                                        onClick={() => addSeconds(sec)}
                                        className="px-4 py-2 bg-gray-800/50 hover:bg-gray-700 rounded-full text-sm font-bold backdrop-blur-sm border border-gray-700/50 transition-all active:scale-95"
                                    >
                                        +{sec}с
                                    </button>
                                ))}
                            </div>

                            {/* Next Interval Preview */}
                            {status !== 'finished' && activeScheme.intervals.length > 0 && (
                                <div className="text-gray-400 text-sm bg-gray-800/50 px-4 py-2 rounded-full backdrop-blur-sm mb-4 shrink-0">Далее: {activeScheme.intervals[(currentIntervalIndex + 1) % activeScheme.intervals.length].name}</div>
                            )}
                        </div>

                        {/* Controls - Always visible, never shrinks */}
                        <div className="pb-6 pt-4 flex justify-center items-center gap-6 safe-bottom z-10 w-full flex-shrink-0 bg-gray-900/10 backdrop-blur-sm">
                            {/* SKIP BACK */}
                            <button onClick={handleSkipBackward} className="w-14 h-14 bg-gray-800 rounded-full flex items-center justify-center shadow-lg hover:bg-gray-700 active:scale-95 transition text-blue-400">
                                <SkipBack size={24} fill="currentColor" />
                            </button>

                            {status === 'running' ? (
                                <button onClick={pauseTimer} className="w-20 h-20 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg hover:scale-105 active:scale-95 transition"><Pause size={32} fill="currentColor" className="text-black" /></button>
                            ) : (
                                <button onClick={startTimer} className="w-20 h-20 bg-green-500 rounded-full flex items-center justify-center shadow-lg hover:scale-105 active:scale-95 transition"><Play size={32} fill="currentColor" className="ml-1 text-black" /></button>
                            )}
                            
                            {/* SKIP FORWARD */}
                            <button onClick={handleIntervalComplete} className="w-14 h-14 bg-gray-800 rounded-full flex items-center justify-center shadow-lg hover:bg-gray-700 active:scale-95 transition text-blue-400">
                                <SkipForward size={24} fill="currentColor" />
                            </button>

                            <button onClick={resetTimer} className="w-14 h-14 bg-gray-800 rounded-full flex items-center justify-center shadow-lg hover:bg-gray-700 active:scale-95 transition">
                                <RotateCcw size={24} />
                            </button>
                        </div>
                        
                        {/* Background Progress Bar */}
                        <div className="h-2 bg-gray-800 w-full absolute bottom-0 z-10">
                            <div className="h-full transition-all duration-100 ease-linear" style={{ width: `${progressPercent}%`, backgroundColor: currentInterval.color }} />
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full w-full bg-gray-900 text-white font-sans overflow-hidden">
                    <div className="p-4 border-b border-gray-800 flex justify-between items-center bg-gray-900 sticky top-0 z-30 safe-top shadow-md">
                        <h1 className="text-xl font-bold">Настройки</h1>
                        <button onClick={() => { setIsSchemeListOpen(false); setMode('timer'); }} className="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded-full flex items-center font-medium transition text-sm"><Check size={16} className="mr-2" /> Готово</button>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 space-y-6 pb-40 safe-bottom">
                        
                        {/* SCHEME SELECTOR */}
                        <div className="bg-gray-800 rounded-2xl p-2 relative z-20">
                             <div 
                                className="flex justify-between items-center p-3 cursor-pointer hover:bg-gray-700/50 rounded-xl transition"
                                onClick={() => setIsSchemeListOpen(!isSchemeListOpen)}
                             >
                                <div className="flex items-center gap-3 overflow-hidden">
                                    <div className="p-2 bg-blue-600 rounded-lg"><List size={20}/></div>
                                    <div className="flex flex-col overflow-hidden">
                                        <span className="text-xs text-gray-400 font-bold uppercase">Активная схема</span>
                                        <span className="font-bold truncate text-white">{activeScheme.name}</span>
                                    </div>
                                </div>
                                <div className={`transform transition-transform ${isSchemeListOpen ? 'rotate-180' : ''}`}><ArrowDown size={16}/></div>
                             </div>

                             {isSchemeListOpen && (
                                 <div className="mt-2 border-t border-gray-700 pt-2 flex flex-col gap-1 max-h-60 overflow-y-auto">
                                     {schemes.map(scheme => (
                                         <div key={scheme.id} className={`p-3 rounded-lg flex justify-between items-center ${scheme.id === activeScheme.id ? 'bg-blue-900/30 text-blue-300' : 'hover:bg-gray-700'}`}>
                                             <button className="flex-1 text-left font-medium" onClick={() => { switchScheme(scheme.id); setIsSchemeListOpen(false); }}>{scheme.name}</button>
                                             {scheme.id === activeScheme.id && <Check size={16} className="text-blue-500"/>}
                                         </div>
                                     ))}
                                     <button 
                                        onClick={() => { addNewScheme(); setIsSchemeListOpen(false); }}
                                        className="p-3 mt-2 rounded-lg border border-dashed border-gray-600 text-center text-gray-400 hover:border-blue-500 hover:text-blue-500 transition text-sm font-medium"
                                     >
                                         + Создать новую схему
                                     </button>
                                 </div>
                             )}
                        </div>

                        {/* SCHEME PROPERTIES */}
                        <div className="bg-gray-800/50 p-4 rounded-2xl border border-gray-700/50">
                            <div className="flex gap-2 mb-4">
                                <div className="flex-1">
                                    <label className="text-gray-500 text-xs uppercase tracking-wider font-bold mb-1 block">Название схемы</label>
                                    <div className="flex items-center bg-gray-900 rounded-lg px-3 py-2">
                                        <Edit size={16} className="text-gray-500 mr-2"/>
                                        <input 
                                            type="text" 
                                            value={activeScheme.name} 
                                            onChange={(e) => updateActiveScheme({ name: e.target.value })} 
                                            className="bg-transparent w-full focus:outline-none font-bold text-white"
                                        />
                                    </div>
                                </div>
                                <div className="flex items-end">
                                    <button 
                                        onClick={deleteActiveScheme} 
                                        disabled={schemes.length <= 1}
                                        className={`p-3 rounded-lg ${schemes.length <= 1 ? 'bg-gray-700 text-gray-500' : 'bg-red-500/10 text-red-400 hover:bg-red-500/20'}`}
                                    >
                                        <Trash2 size={20} />
                                    </button>
                                </div>
                            </div>

                            <div className="bg-gray-900 rounded-xl p-4">
                                <label className="text-gray-400 text-xs uppercase tracking-wider font-bold mb-3 block">Количество циклов</label>
                                <div className="flex items-center gap-4">
                                    <input 
                                        type="range" 
                                        min="1" 
                                        max="99" 
                                        value={activeScheme.cycles} 
                                        onChange={(e) => updateActiveScheme({ cycles: parseInt(e.target.value) })} 
                                        className="flex-1 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500" 
                                    />
                                    <div className="text-2xl font-bold w-16 text-center bg-gray-800 rounded-lg py-1">{activeScheme.cycles}</div>
                                </div>
                            </div>
                        </div>

                        {/* INTERVALS LIST */}
                        <div className="space-y-4">
                            <div className="flex justify-between items-end px-1"><span className="text-gray-400 text-xs uppercase tracking-wider font-bold">Интервалы</span></div>
                            {activeScheme.intervals.map((interval, index) => (
                                <div key={interval.id} className="bg-gray-800 rounded-2xl p-4 flex flex-col gap-4 border-l-4" style={{ borderColor: interval.color }}>
                                    
                                    <div className="flex justify-between items-center gap-2">
                                        <div className="bg-gray-900/50 p-2 rounded-lg text-gray-500 flex-1 flex items-center min-w-0">
                                            <span className="text-xs font-mono opacity-50 mr-2">#{index + 1}</span>
                                            <input type="text" value={interval.name} onChange={(e) => updateIntervalData(interval.id, 'name', e.target.value)} className="bg-transparent border-none text-lg font-bold focus:ring-0 focus:outline-none w-full text-white min-w-0" />
                                        </div>
                                        
                                        <div className="flex items-center gap-1">
                                            <button onClick={() => moveInterval(index, -1)} disabled={index === 0} className={`p-2 rounded-full ${index === 0 ? 'opacity-20' : 'hover:bg-gray-700 text-gray-400'}`}><ArrowUp size={16} /></button>
                                            <button onClick={() => moveInterval(index, 1)} disabled={index === activeScheme.intervals.length - 1} className={`p-2 rounded-full ${index === activeScheme.intervals.length - 1 ? 'opacity-20' : 'hover:bg-gray-700 text-gray-400'}`}><ArrowDown size={16} /></button>
                                            <button onClick={() => duplicateInterval(interval.id)} className="p-2 rounded-full hover:bg-gray-700 text-blue-400" title="Копировать"><Copy size={16} /></button>
                                            <button onClick={() => removeInterval(interval.id)} disabled={activeScheme.intervals.length === 1} className={`p-2 rounded-full ${activeScheme.intervals.length === 1 ? 'opacity-30' : 'hover:bg-red-500/20 text-red-400'}`}><Trash2 size={18} /></button>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                                        <div className="bg-gray-900 rounded-xl p-2 flex flex-col justify-center">
                                            <label className="text-xs text-gray-500 mb-1">Секунды</label>
                                            <input type="number" value={interval.duration} 
                                                onChange={(e) => {
                                                    const val = e.target.value;
                                                    updateIntervalData(interval.id, 'duration', val === '' ? '' : parseInt(val));
                                                }}
                                                className="bg-transparent text-xl font-bold w-full focus:outline-none" 
                                            />
                                        </div>
                                        <div className="bg-gray-900 rounded-xl p-2 flex flex-col justify-center relative overflow-hidden">
                                            <label className="text-xs text-gray-500 mb-1">Цвет</label>
                                            <div className="flex items-center gap-2">
                                                <div className="w-6 h-6 rounded-full shadow-sm" style={{ backgroundColor: interval.color }}></div>
                                                <input type="color" value={interval.color} onChange={(e) => updateIntervalData(interval.id, 'color', e.target.value)} className="absolute inset-0 opacity-0 w-full h-full cursor-pointer" />
                                            </div>
                                        </div>
                                        <div className="col-span-2 bg-gray-900 rounded-xl p-2 flex items-center gap-2">
                                            <div className="flex-1">
                                                <label className="text-xs text-gray-500 mb-1 block">Звук</label>
                                                <select value={interval.soundType} onChange={(e) => updateIntervalData(interval.id, 'soundType', e.target.value)} className="bg-transparent text-sm font-medium focus:outline-none w-full appearance-none text-white [&>option]:bg-gray-800 [&>option]:text-white [&>optgroup]:bg-gray-800 [&>optgroup]:text-white">
                                                    <optgroup label="Встроенные" className="bg-gray-800 text-white">
                                                        <option value="low">Низкий (Бип)</option>
                                                        <option value="high">Высокий (Пик)</option>
                                                        <option value="bell">Гонг</option>
                                                        <option value="whistle">Свисток</option>
                                                        <option value="game">8-бит</option>
                                                    </optgroup>
                                                    <option value="custom">Свой файл...</option>
                                                </select>
                                            </div>
                                            {interval.soundType === 'custom' && (
                                                <div className="relative group">
                                                    <button className={`p-2 rounded-full ${interval.customUrl ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-400'}`}><Upload size={18} /></button>
                                                    <input type="file" accept="audio/*" onChange={(e) => handleFileUpload(interval.id, e.target.files[0])} className="absolute inset-0 opacity-0 cursor-pointer w-full" />
                                                </div>
                                            )}
                                            <button onClick={() => playSound(interval.soundType, interval.customUrl)} className="p-2 text-green-400 hover:bg-gray-800 rounded-full"><Volume2 size={18} /></button>
                                        </div>
                                    </div>
                                </div>
                            ))}
                            <button onClick={addInterval} className="w-full py-4 rounded-2xl border-2 border-dashed border-gray-700 text-gray-400 hover:border-blue-500 hover:text-blue-500 transition flex justify-center items-center gap-2 mb-8"><Plus size={20} /> Добавить этап</button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ChronoFlexTimer />);
    </script>
</body>
</html>
