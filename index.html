<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ChronoFlex Pro</title>
    
    <!-- Подключаем стили Tailwind (Дизайн) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Подключаем React и ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (чтобы браузер понял современный код) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Отключаем выделение текста на мобильных для ощущения приложения */
        body {
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        /* Анимации */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.5s ease-out forwards;
        }
        /* Безопасные зоны для телефонов с "челками" */
        .safe-top { padding-top: env(safe-area-inset-top); }
        .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ВСТРОЕННЫЕ ИКОНКИ (Замена внешней библиотеке Lucide) ---
        // Это решает проблему "ReferenceError: lucideReact is not defined"
        const Icons = {
            Play: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
            Pause: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
            RotateCcw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>,
            Plus: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>,
            Trash2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>,
            Settings: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>,
            Volume2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>,
            Music: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>,
            Check: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>,
            X: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Upload: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
        };

        const { Play, Pause, RotateCcw, Plus, Trash2, Settings, Volume2, Music, Check, X, Upload } = Icons;

        // --- DATABASE UTILS (IndexedDB) ---
        const DB_NAME = 'ChronoFlexAudioDB';
        const STORE_NAME = 'audio_files';

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        };

        const saveAudioToDB = async (id, file) => {
            try {
                const db = await initDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).put(file, id);
                return new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            } catch (err) { console.error("DB Error", err); }
        };

        const getAudioFromDB = async (id) => {
            try {
                const db = await initDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });
            } catch (err) { return null; }
        };

        const deleteAudioFromDB = async (id) => {
            try {
                const db = await initDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).delete(id);
            } catch (err) {}
        };

        // --- SOUND ENGINE ---
        const playSound = (type, customBlobUrl = null) => {
            if (type === 'custom' && customBlobUrl) {
                const audio = new Audio(customBlobUrl);
                audio.play().catch(e => console.log(e));
                return;
            }

            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            const now = ctx.currentTime;

            switch (type) {
                case 'bell':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(330, now);
                    const osc2 = ctx.createOscillator();
                    const gain2 = ctx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(ctx.destination);
                    osc2.frequency.setValueAtTime(587, now);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 2.5);
                    gain2.gain.setValueAtTime(0.3, now);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    osc.start(now); osc.stop(now + 2.5);
                    osc2.start(now); osc2.stop(now + 2.5);
                    break;
                case 'whistle':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(1500, now);
                    osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'game':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.setValueAtTime(880, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.21);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'high':
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'finish':
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                        const o = ctx.createOscillator();
                        const g = ctx.createGain();
                        o.connect(g);
                        g.connect(ctx.destination);
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.2, now + i * 0.15);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 1);
                        o.start(now + i * 0.15);
                        o.stop(now + i * 0.15 + 1);
                    });
                    break;
                default:
                    osc.frequency.setValueAtTime(440, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
            }
        };

        const formatTime = (seconds) => {
            const m = Math.floor(seconds / 60).toString().padStart(2, '0');
            const s = (seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        };

        // --- MAIN APP COMPONENT ---
        function ChronoFlexTimer() {
            const [intervals, setIntervals] = useState(() => {
                const saved = localStorage.getItem('chrono_intervals');
                if (saved) {
                    try { return JSON.parse(saved); } catch (e) {}
                }
                return [
                    { id: 1, name: 'Разминка', duration: 10, color: '#10b981', soundType: 'low', customUrl: null },
                    { id: 2, name: 'Работа', duration: 30, color: '#ef4444', soundType: 'bell', customUrl: null },
                    { id: 3, name: 'Отдых', duration: 15, color: '#3b82f6', soundType: 'low', customUrl: null }
                ];
            });

            const [cycles, setCycles] = useState(() => {
                const saved = localStorage.getItem('chrono_cycles');
                return saved ? parseInt(saved, 10) : 1;
            });

            const [currentCycle, setCurrentCycle] = useState(1);
            const [currentIntervalIndex, setCurrentIntervalIndex] = useState(0);
            const [timeLeft, setTimeLeft] = useState(intervals[0]?.duration || 0);
            const [status, setStatus] = useState('idle');
            const [mode, setMode] = useState('timer');

            const endTimeRef = useRef(null);
            const rafRef = useRef(null);
            const wakeLockRef = useRef(null);

            useEffect(() => {
                const restoreAudio = async () => {
                    const updatedIntervals = [...intervals];
                    let hasChanges = false;
                    for (let i = 0; i < updatedIntervals.length; i++) {
                        if (updatedIntervals[i].soundType === 'custom') {
                            const fileBlob = await getAudioFromDB(updatedIntervals[i].id);
                            if (fileBlob) {
                                updatedIntervals[i].customUrl = URL.createObjectURL(fileBlob);
                                hasChanges = true;
                            } else {
                                updatedIntervals[i].soundType = 'low';
                            }
                        }
                    }
                    if (hasChanges) setIntervals(updatedIntervals);
                };
                restoreAudio();
            }, []);

            useEffect(() => {
                const toSave = intervals.map(i => ({ ...i, customUrl: null }));
                localStorage.setItem('chrono_intervals', JSON.stringify(toSave));
            }, [intervals]);

            useEffect(() => {
                localStorage.setItem('chrono_cycles', cycles.toString());
            }, [cycles]);

            const requestWakeLock = async () => {
                try { if ('wakeLock' in navigator) wakeLockRef.current = await navigator.wakeLock.request('screen'); } catch (err) {}
            };

            const startTimer = () => {
                if (status === 'finished') { resetTimer(); return; }
                setStatus('running');
                requestWakeLock();
                endTimeRef.current = Date.now() + (timeLeft * 1000);
                if (timeLeft === intervals[currentIntervalIndex].duration) {
                    const current = intervals[currentIntervalIndex];
                    playSound(current.soundType, current.customUrl);
                }
            };

            const pauseTimer = () => {
                setStatus('paused');
                if (wakeLockRef.current) wakeLockRef.current.release();
                if (rafRef.current) cancelAnimationFrame(rafRef.current);
            };

            const resetTimer = () => {
                pauseTimer();
                setStatus('idle');
                setCurrentCycle(1);
                setCurrentIntervalIndex(0);
                setTimeLeft(intervals[0].duration);
            };

            const tick = useCallback(() => {
                if (status !== 'running') return;
                const now = Date.now();
                const remainingMs = endTimeRef.current - now;
                const remainingSec = Math.ceil(remainingMs / 1000);

                if (remainingSec !== timeLeft) setTimeLeft(remainingSec >= 0 ? remainingSec : 0);

                if (remainingMs <= 0) handleIntervalComplete();
                else rafRef.current = requestAnimationFrame(tick);
            }, [status, timeLeft, intervals]);

            useEffect(() => {
                if (status === 'running') rafRef.current = requestAnimationFrame(tick);
                return () => cancelAnimationFrame(rafRef.current);
            }, [status, tick]);

            const handleIntervalComplete = () => {
                const nextIndex = currentIntervalIndex + 1;
                if (nextIndex < intervals.length) {
                    setCurrentIntervalIndex(nextIndex);
                    const nextInterval = intervals[nextIndex];
                    setTimeLeft(nextInterval.duration);
                    endTimeRef.current = Date.now() + (nextInterval.duration * 1000);
                    playSound(nextInterval.soundType, nextInterval.customUrl);
                } else {
                    if (currentCycle < cycles) {
                        setCurrentCycle(c => c + 1);
                        setCurrentIntervalIndex(0);
                        const first = intervals[0];
                        setTimeLeft(first.duration);
                        endTimeRef.current = Date.now() + (first.duration * 1000);
                        playSound(first.soundType, first.customUrl);
                    } else {
                        setStatus('finished');
                        setTimeLeft(0);
                        playSound('finish');
                    }
                }
            };

            const addInterval = () => {
                const newId = Date.now();
                setIntervals([...intervals, { id: newId, name: 'Новый этап', duration: 30, color: '#6366f1', soundType: 'low', customUrl: null }]);
            };

            const removeInterval = (id) => {
                if (intervals.length > 1) {
                    setIntervals(intervals.filter(i => i.id !== id));
                    deleteAudioFromDB(id);
                }
            };

            const updateInterval = (id, field, value) => {
                setIntervals(intervals.map(i => i.id === id ? { ...i, [field]: value } : i));
            };

            const handleFileUpload = async (id, file) => {
                if (file) {
                    await saveAudioToDB(id, file);
                    const url = URL.createObjectURL(file);
                    setIntervals(intervals.map(i => i.id === id ? { ...i, soundType: 'custom', customUrl: url } : i));
                }
            };

            const currentInterval = intervals[currentIntervalIndex];
            const progressPercent = status === 'idle' ? 100 : (timeLeft / currentInterval.duration) * 100;

            if (mode === 'timer') {
                return (
                    <div className="flex flex-col h-screen overflow-hidden transition-colors duration-700"
                        style={{ backgroundColor: status !== 'idle' && status !== 'finished' ? `${currentInterval.color}20` : '#111827' }}>
                        
                        <div className="flex justify-between items-center p-6 safe-top">
                            <div className="text-sm font-medium opacity-70 tracking-widest uppercase">Цикл {currentCycle} / {cycles}</div>
                            <button onClick={() => { resetTimer(); setMode('edit'); }} className="p-2 bg-gray-800 rounded-full hover:bg-gray-700 transition"><Settings size={20} /></button>
                        </div>

                        <div className="flex-1 flex flex-col items-center justify-center relative">
                            <div className="absolute inset-0 flex items-center justify-center opacity-10 pointer-events-none">
                                <div className="w-80 h-80 rounded-full border-8 transition-colors duration-500" style={{ borderColor: currentInterval.color }}></div>
                            </div>
                            <h2 className="text-3xl font-light mb-4 text-center px-4 animate-fade-in">{status === 'finished' ? 'Тренировка завершена!' : currentInterval.name}</h2>
                            <div className="text-9xl font-bold tracking-tighter tabular-nums mb-8 drop-shadow-2xl" style={{ color: status === 'finished' ? '#10b981' : currentInterval.color }}>{formatTime(timeLeft)}</div>
                            {status !== 'finished' && (
                                <div className="text-gray-400 text-sm bg-gray-800/50 px-4 py-2 rounded-full backdrop-blur-sm">Далее: {intervals[(currentIntervalIndex + 1) % intervals.length].name}</div>
                            )}
                        </div>

                        <div className="p-8 pb-12 flex justify-center gap-6 safe-bottom">
                            {status === 'running' ? (
                                <button onClick={pauseTimer} className="w-20 h-20 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg hover:scale-105 active:scale-95 transition"><Pause size={32} fill="currentColor" className="text-black" /></button>
                            ) : (
                                <button onClick={startTimer} className="w-20 h-20 bg-green-500 rounded-full flex items-center justify-center shadow-lg hover:scale-105 active:scale-95 transition"><Play size={32} fill="currentColor" className="ml-1 text-black" /></button>
                            )}
                            <button onClick={resetTimer} className="w-20 h-20 bg-gray-800 rounded-full flex items-center justify-center shadow-lg hover:bg-gray-700 active:scale-95 transition"><RotateCcw size={28} /></button>
                        </div>
                        <div className="h-2 bg-gray-800 w-full relative">
                            <div className="h-full transition-all duration-100 ease-linear" style={{ width: `${progressPercent}%`, backgroundColor: currentInterval.color }} />
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-screen bg-gray-900 text-white font-sans">
                    <div className="p-6 pb-2 border-b border-gray-800 flex justify-between items-center bg-gray-900 sticky top-0 z-10 safe-top">
                        <h1 className="text-2xl font-bold">Настройки</h1>
                        <button onClick={() => setMode('timer')} className="bg-green-600 hover:bg-green-500 text-white px-6 py-2 rounded-full flex items-center font-medium transition"><Check size={18} className="mr-2" /> Готово</button>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 space-y-6 safe-bottom">
                        <div className="bg-gray-800 p-5 rounded-2xl">
                            <label className="text-gray-400 text-xs uppercase tracking-wider font-bold mb-2 block">Циклы</label>
                            <div className="flex items-center gap-4">
                                <input type="range" min="1" max="99" value={cycles} onChange={(e) => setCycles(parseInt(e.target.value))} className="flex-1 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500" />
                                <div className="text-2xl font-bold w-16 text-center bg-gray-900 rounded-lg py-1">{cycles}</div>
                            </div>
                        </div>

                        <div className="space-y-4">
                            <div className="flex justify-between items-end px-1"><span className="text-gray-400 text-xs uppercase tracking-wider font-bold">Интервалы</span></div>
                            {intervals.map((interval, index) => (
                                <div key={interval.id} className="bg-gray-800 rounded-2xl p-4 flex flex-col gap-4 border-l-4" style={{ borderColor: interval.color }}>
                                    <div className="flex justify-between items-center gap-2">
                                        <div className="bg-gray-900/50 p-2 rounded-lg text-gray-500 w-full flex items-center">
                                            <span className="text-xs font-mono opacity-50 mr-2">#{index + 1}</span>
                                            <input type="text" value={interval.name} onChange={(e) => updateInterval(interval.id, 'name', e.target.value)} className="bg-transparent border-none text-lg font-bold focus:ring-0 focus:outline-none w-full text-white" />
                                        </div>
                                        <button onClick={() => removeInterval(interval.id)} disabled={intervals.length === 1} className={`p-2 rounded-full ${intervals.length === 1 ? 'opacity-30' : 'hover:bg-red-500/20 text-red-400'}`}><Trash2 size={18} /></button>
                                    </div>
                                    <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                                        <div className="bg-gray-900 rounded-xl p-2 flex flex-col justify-center">
                                            <label className="text-xs text-gray-500 mb-1">Секунды</label>
                                            <input type="number" value={interval.duration} onChange={(e) => updateInterval(interval.id, 'duration', parseInt(e.target.value) || 0)} className="bg-transparent text-xl font-bold w-full focus:outline-none" />
                                        </div>
                                        <div className="bg-gray-900 rounded-xl p-2 flex flex-col justify-center relative overflow-hidden">
                                            <label className="text-xs text-gray-500 mb-1">Цвет</label>
                                            <div className="flex items-center gap-2">
                                                <div className="w-6 h-6 rounded-full shadow-sm" style={{ backgroundColor: interval.color }}></div>
                                                <input type="color" value={interval.color} onChange={(e) => updateInterval(interval.id, 'color', e.target.value)} className="absolute inset-0 opacity-0 w-full h-full cursor-pointer" />
                                            </div>
                                        </div>
                                        <div className="col-span-2 bg-gray-900 rounded-xl p-2 flex items-center gap-2">
                                            <div className="flex-1">
                                                <label className="text-xs text-gray-500 mb-1 block">Звук</label>
                                                <select value={interval.soundType} onChange={(e) => updateInterval(interval.id, 'soundType', e.target.value)} className="bg-transparent text-sm font-medium focus:outline-none w-full appearance-none text-white [&>option]:bg-gray-800 [&>option]:text-white [&>optgroup]:bg-gray-800 [&>optgroup]:text-white">
                                                    <optgroup label="Встроенные" className="bg-gray-800 text-white">
                                                        <option value="low">Низкий (Бип)</option>
                                                        <option value="high">Высокий (Пик)</option>
                                                        <option value="bell">Гонг</option>
                                                        <option value="whistle">Свисток</option>
                                                        <option value="game">8-бит</option>
                                                    </optgroup>
                                                    <option value="custom">Свой файл...</option>
                                                </select>
                                            </div>
                                            {interval.soundType === 'custom' && (
                                                <div className="relative group">
                                                    <button className={`p-2 rounded-full ${interval.customUrl ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-400'}`}><Upload size={18} /></button>
                                                    <input type="file" accept="audio/*" onChange={(e) => handleFileUpload(interval.id, e.target.files[0])} className="absolute inset-0 opacity-0 cursor-pointer w-full" />
                                                </div>
                                            )}
                                            <button onClick={() => playSound(interval.soundType, interval.customUrl)} className="p-2 text-green-400 hover:bg-gray-800 rounded-full"><Volume2 size={18} /></button>
                                        </div>
                                    </div>
                                </div>
                            ))}
                            <button onClick={addInterval} className="w-full py-4 rounded-2xl border-2 border-dashed border-gray-700 text-gray-400 hover:border-blue-500 hover:text-blue-500 transition flex justify-center items-center gap-2"><Plus size={20} /> Добавить этап</button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ChronoFlexTimer />);
    </script>
</body>
</html>